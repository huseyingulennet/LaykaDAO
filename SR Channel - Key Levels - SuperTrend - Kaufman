//@version=5

// ╔══════════════════════════════════════════════════════════════════════════════╗
// ║                                                                              ║
// ║ © www.huseyingulen.net                                                       ║
// ║                                                                              ║
// ║ SR Channel                                                                   ║
// ║ Key Levels                                                                   ║
// ║ Supertrend                                                                   ║
// ║ Kaufmann                                                                     ║
// ║                                                                              ║ 
// ║ developer : husseyingulen                                                    ║    
// ║ creators  : LonesomeTheblue, Spaceman, everget, Hpotter                      ║
// ║                                                                              ║
// ║ This source code is subject to the terms of the Mozilla Public License 2.0   ║
// ║ at https://mozilla.org/MPL/2.0/                                              ║
// ║                                                                              ║
// ╚══════════════════════════════════════════════════════════════════════════════╝


// ╔══════════════════════════════════════╗
// ║                                      ║
// ║     colors                           ║
// ║                                      ║
// ╚══════════════════════════════════════╝


// v3 Style Gradient
GRN01 = #7CFC00, GRN02 = #32CD32, GRN03 = #228B22, GRN04 = #006400, GRN05 = #008000, GRN06=#093507
RED01 = #FF4500, RED02 = #FF0000, RED03 = #B22222, RED04 = #8B0000, RED05 = #800000, RED06=#330d06

// ──────────[ v3 Style Colors ]
AQUA    = #00FFFF
BLACK   = #000000
BLUE    = #0000FF
FUCHSIA = #FF00FF
GRAY    = #808080
GREEN   = #008000
LIME    = #00FF00
MAROON  = #800000
NAVY    = #000080
OLIVE   = #808000
ORANGE  = #FF7F00
PURPLE  = #800080
RUBI    = #FF0000
SILVER  = #C0C0C0
TEAL    = #008080
YELLOW  = #FFFF00
WHITE   = #FFFFFF 

// ╔══════════════════════════════════════╗
// ║                                      ║
// ║     indicator functions              ║
// ║                                      ║
// ╚══════════════════════════════════════╝


indicator(title='SR Channel - Key Levels - SuperTrend - Kaufman', overlay=true, max_bars_back=1000, max_lines_count=500, max_labels_count=400, max_boxes_count=200)


// ╔══════════════════════════════════════════════════════════════════════════════╗
// ║                                                                              ║
// ║     main start (supertrend)                                                  ║
// ║                                                                              ║
// ╚══════════════════════════════════════════════════════════════════════════════╝


length = input(title='ATR Period', defval=22)
mult = input.float(title='ATR Multiplier', step=0.1, defval=3)
src = input(title='Source', defval=hl2)
wicks = input(title='Take Wicks into Account ?', defval=false)
showLabels = input(title='Show Buy/Sell Labels ?', defval=true)
highlightState = input(title='Highlight State ?', defval=true)

atr = mult * ta.atr(length)

highPrice = wicks ? high : close
lowPrice = wicks ? low : close
doji4price = open == close and open == low and open == high

longStop = src - atr
longStopPrev = nz(longStop[1], longStop)

if longStop > 0
    if doji4price
        longStop := longStopPrev
        longStop
    else
        longStop := lowPrice[1] > longStopPrev ? math.max(longStop, longStopPrev) : longStop
        longStop
else
    longStop := longStopPrev
    longStop

shortStop = src + atr
shortStopPrev = nz(shortStop[1], shortStop)

if shortStop > 0
    if doji4price
        shortStop := shortStopPrev
        shortStop
    else
        shortStop := highPrice[1] < shortStopPrev ? math.min(shortStop, shortStopPrev) : shortStop
        shortStop
else
    shortStop := shortStopPrev
    shortStop

var int dir = 1
dir := dir == -1 and highPrice > shortStopPrev ? 1 : dir == 1 and lowPrice < longStopPrev ? -1 : dir

var color longColor = color.green
var color shortColor = color.red

longStopPlot = plot(dir == 1 ? longStop : na, title='Long Stop', style=plot.style_linebr, linewidth=2, color=color.new(longColor, 0))
buySignal = dir == 1 and dir[1] == -1
plotshape(buySignal ? longStop : na, title='Long Stop Start', location=location.absolute, style=shape.circle, size=size.tiny, color=color.new(longColor, 0))
plotshape(buySignal and showLabels ? longStop : na, title='Buy Label', text='Buy Trend', location=location.absolute, style=shape.labelup, size=size.tiny, color=color.new(longColor, 0), textcolor=color.new(color.white, 0))

shortStopPlot = plot(dir == 1 ? na : shortStop, title='Short Stop', style=plot.style_linebr, linewidth=2, color=color.new(shortColor, 0))
sellSignal = dir == -1 and dir[1] == 1
plotshape(sellSignal ? shortStop : na, title='Short Stop Start', location=location.absolute, style=shape.circle, size=size.tiny, color=color.new(shortColor, 0))
plotshape(sellSignal and showLabels ? shortStop : na, title='Sell Label', text='Sell Trend', location=location.absolute, style=shape.labeldown, size=size.tiny, color=color.new(shortColor, 0), textcolor=color.new(color.white, 0))

midPricePlot = plot(ohlc4, title='', style=plot.style_circles, linewidth=0, display=display.none, editable=false)

longFillColor = highlightState ? dir == 1 ? longColor : na : na
shortFillColor = highlightState ? dir == -1 ? shortColor : na : na
fill(midPricePlot, longStopPlot, title='Long State Filling', color=longFillColor, transp=90)
fill(midPricePlot, shortStopPlot, title='Short State Filling', color=shortFillColor, transp=90)

changeCond = dir != dir[1]
alertcondition(changeCond, title='Alert: SuperTrend Direction Change', message='SuperTrend has changed direction!\nSymbol: {{exchange}}:{{ticker}}\nPrice: {{close}}')
alertcondition(buySignal, title='Alert: SuperTrend Buy', message='SuperTrend Buy!\nSymbol: {{exchange}}:{{ticker}}\nPrice: {{close}}')
alertcondition(sellSignal, title='Alert: SuperTrend Sell', message='SuperTrend Sell!\nSymbol: {{exchange}}:{{ticker}}\nPrice: {{close}}')

// ╔══════════════════════════════════════════════════════════════════════════════╗
// ║                                                                              ║
// ║     main finish (supertrend)                                                 ║
// ║                                                                              ║
// ╚══════════════════════════════════════════════════════════════════════════════╝


// ╔══════════════════════════════════════════════════════════════════════════════╗
// ║                                                                              ║
// ║     main start (kaufman)                                                     ║
// ║                                                                              ║
// ╚══════════════════════════════════════════════════════════════════════════════╝

Length = input.int(21, minval=1)
xPrice = close
xvnoise = math.abs(xPrice - xPrice[1])
nAMA = 0.0
nfastend = 0.666
nslowend = 0.0645
nsignal = math.abs(xPrice - xPrice[Length])
nnoise = math.sum(xvnoise, Length)
nefratio = nnoise != 0 ? nsignal / nnoise : 0
nsmooth = math.pow(nefratio * (nfastend - nslowend) + nslowend, 2)
nAMA := nz(nAMA[1]) + nsmooth * (xPrice - nz(nAMA[1]))
plot(nAMA, color=color.new(color.blue, 0), title='KAMA')

// ╔══════════════════════════════════════════════════════════════════════════════╗
// ║                                                                              ║
// ║     main finish (kaufman)                                                    ║
// ║                                                                              ║
// ╚══════════════════════════════════════════════════════════════════════════════╝


// ╔══════════════════════════════════════════════════════════════════════════════╗
// ║                                                                              ║
// ║     main start (support resistance)                                          ║
// ║                                                                              ║
// ╚══════════════════════════════════════════════════════════════════════════════╝

prd = input.int(defval=10, title='Pivot Period', minval=4, maxval=30, group='=== S/R CHANNEL SETTINGS ===', tooltip='Used while calculating Pivot Points, checks left&right bars')
ppsrc = input.string(defval='High/Low', title='Source', options=['High/Low', 'Close/Open'], group='=== S/R CHANNEL SETTINGS ===', tooltip='Source for Pivot Points')
ChannelW = input.int(defval=5, title='Maximum Channel Width %', minval=1, maxval=8, group='=== S/R CHANNEL SETTINGS ===', tooltip='Calculated using Highest/Lowest levels in 300 bars')
minstrength = input.int(defval=1, title='Minimum Strength', minval=1, group='=== S/R CHANNEL SETTINGS ===', tooltip='Channel must contain at least 2 Pivot Points')
maxnumsr = input.int(defval=6, title='Maximum Number of S/R', minval=1, maxval=10, group='=== S/R CHANNEL SETTINGS ===', tooltip='Maximum number of Support/Resistance Channels to Show') - 1
loopback = input.int(defval=400, title='Loopback Period', minval=100, maxval=400, group='=== S/R CHANNEL SETTINGS ===', tooltip='While calculating S/R levels it checks Pivots in Loopback Period')
res_col = input.color(defval=color.new(color=#f7525f, transp=65), title='Resistance Color', group='=== S/R COLOR SETTINGS ===')
sup_col = input.color(defval=color.new(color=#00e676, transp=65), title='Support Color', group='=== S/R COLOR SETTINGS ===')
inch_col = input.color(defval=color.new(color=#ffeb3b, transp=50), title='Color When Price in Channel', group='=== S/R COLOR SETTINGS ===')
showpp = input.bool(defval=false, title='Show Pivot Points', group='=== S/R EXTRA SETTINGS ===')
showsrbroken = input.bool(defval=false, title='Show Broken Support/Resistance', group='=== S/R EXTRA SETTINGS ===')


// get Pivot High/low
float src1 = ppsrc == 'High/Low' ? high : math.max(close, open)
float src2 = ppsrc == 'High/Low' ? low : math.min(close, open)
float ph = ta.pivothigh(src1, prd, prd)
float pl = ta.pivotlow(src2, prd, prd)

// draw Pivot points
plotshape(ph and showpp, text='H', style=shape.labeldown, color=na, textcolor=color.new(color.red, 0), location=location.abovebar, offset=-prd)
plotshape(pl and showpp, text='L', style=shape.labelup, color=na, textcolor=color.new(color.lime, 0), location=location.belowbar, offset=-prd)

//calculate maximum S/R channel width
prdhighest = ta.highest(300)
prdlowest = ta.lowest(300)
cwidth = (prdhighest - prdlowest) * ChannelW / 100

// get/keep Pivot levels
var pivotvals = array.new_float(0)
var pivotlocs = array.new_float(0)
if ph or pl
    array.unshift(pivotvals, ph ? ph : pl)
    array.unshift(pivotlocs, bar_index)
    for x = array.size(pivotvals) - 1 to 0 by 1
        if bar_index - array.get(pivotlocs, x) > loopback  // remove old pivot points
            array.pop(pivotvals)
            array.pop(pivotlocs)
            continue
        break

//find/create SR channel of a pivot point
get_sr_vals(ind) =>
    float lo = array.get(pivotvals, ind)
    float hi = lo
    int numpp = 0
    for y = 0 to array.size(pivotvals) - 1 by 1
        float cpp = array.get(pivotvals, y)
        float wdth = cpp <= hi ? hi - cpp : cpp - lo
        if wdth <= cwidth  // fits the max channel width?
            if cpp <= hi
                lo := math.min(lo, cpp)
                lo
            else
                hi := math.max(hi, cpp)
                hi

            numpp += 20  // each pivot point added as 20
            numpp
    [hi, lo, numpp]

// keep old SR channels and calculate/sort new channels if we met new pivot point
var suportresistance = array.new_float(20, 0)  // min/max levels
changeit(x, y) =>
    tmp = array.get(suportresistance, y * 2)
    array.set(suportresistance, y * 2, array.get(suportresistance, x * 2))
    array.set(suportresistance, x * 2, tmp)
    tmp := array.get(suportresistance, y * 2 + 1)
    array.set(suportresistance, y * 2 + 1, array.get(suportresistance, x * 2 + 1))
    array.set(suportresistance, x * 2 + 1, tmp)

if ph or pl
    supres = array.new_float(0)  // number of pivot, strength, min/max levels
    stren = array.new_float(10, 0)
    // get levels and strengs
    for x = 0 to array.size(pivotvals) - 1 by 1
        [hi, lo, strength] = get_sr_vals(x)
        array.push(supres, strength)
        array.push(supres, hi)
        array.push(supres, lo)

    // add each HL to strengh
    for x = 0 to array.size(pivotvals) - 1 by 1
        h = array.get(supres, x * 3 + 1)
        l = array.get(supres, x * 3 + 2)
        s = 0
        for y = 0 to loopback by 1
            if high[y] <= h and high[y] >= l or low[y] <= h and low[y] >= l
                s += 1
                s
        array.set(supres, x * 3, array.get(supres, x * 3) + s)

    //reset SR levels
    array.fill(suportresistance, 0)
    // get strongest SRs
    src = 0
    for x = 0 to array.size(pivotvals) - 1 by 1
        stv = -1.  // value
        stl = -1  // location
        for y = 0 to array.size(pivotvals) - 1 by 1
            if array.get(supres, y * 3) > stv and array.get(supres, y * 3) >= minstrength * 20
                stv := array.get(supres, y * 3)
                stl := y
                stl
        if stl >= 0
            //get sr level
            hh = array.get(supres, stl * 3 + 1)
            ll = array.get(supres, stl * 3 + 2)
            array.set(suportresistance, src * 2, hh)
            array.set(suportresistance, src * 2 + 1, ll)
            array.set(stren, src, array.get(supres, stl * 3))

            // make included pivot points' strength zero 
            for y = 0 to array.size(pivotvals) - 1 by 1
                if array.get(supres, y * 3 + 1) <= hh and array.get(supres, y * 3 + 1) >= ll or array.get(supres, y * 3 + 2) <= hh and array.get(supres, y * 3 + 2) >= ll
                    array.set(supres, y * 3, -1)

            src += 1
            if src >= 10
                break

    for x = 0 to 8 by 1
        for y = x + 1 to 9 by 1
            if array.get(stren, y) > array.get(stren, x)
                tmp = array.get(stren, y)
                array.set(stren, y, array.get(stren, x))
                changeit(x, y)


get_level(ind) =>
    float ret = na
    if ind < array.size(suportresistance)
        if array.get(suportresistance, ind) != 0
            ret := array.get(suportresistance, ind)
            ret
    ret

get_color(ind) =>
    color ret = na
    if ind < array.size(suportresistance)
        if array.get(suportresistance, ind) != 0
            ret := array.get(suportresistance, ind) > close and array.get(suportresistance, ind + 1) > close ? res_col : array.get(suportresistance, ind) < close and array.get(suportresistance, ind + 1) < close ? sup_col : inch_col
            ret
    ret

var srchannels = array.new_box(10)
for x = 0 to math.min(9, maxnumsr) by 1
    box.delete(array.get(srchannels, x))
    srcol = get_color(x * 2)
    if not na(srcol)
        array.set(srchannels, x, box.new(left=bar_index, top=get_level(x * 2), right=bar_index + 1, bottom=get_level(x * 2 + 1), border_color=srcol, border_width=0, extend=extend.left, bgcolor=srcol))

resistancebroken = false
supportbroken = false

// check if it's not in a channel
not_in_a_channel = true
for x = 0 to math.min(9, maxnumsr) by 1
    if close <= array.get(suportresistance, x * 2) and close >= array.get(suportresistance, x * 2 + 1)
        not_in_a_channel := false
        not_in_a_channel

// if price is not in a channel then check broken ones
if not_in_a_channel
    for x = 0 to math.min(9, maxnumsr) by 1
        if close[1] <= array.get(suportresistance, x * 2) and close > array.get(suportresistance, x * 2)
            resistancebroken := true
            resistancebroken
        if close[1] >= array.get(suportresistance, x * 2 + 1) and close < array.get(suportresistance, x * 2 + 1)
            supportbroken := true
            supportbroken

alertcondition(resistancebroken, title='Resistance Broken', message='Resistance Broken')
alertcondition(supportbroken, title='Support Broken', message='Support Broken')
plotshape(showsrbroken and resistancebroken, style=shape.triangleup, location=location.belowbar, color=color.new(color.lime, 0), size=size.tiny)
plotshape(showsrbroken and supportbroken, style=shape.triangledown, location=location.abovebar, color=color.new(color.red, 0), size=size.tiny)

// ╔══════════════════════════════════════════════════════════════════════════════╗
// ║                                                                              ║
// ║     main finish (support resistance)                                         ║
// ║                                                                              ║
// ╚══════════════════════════════════════════════════════════════════════════════╝


// ╔══════════════════════════════════════════════════════════════════════════════╗
// ║                                                                              ║
// ║     main start (key levels)                                                  ║
// ║                                                                              ║
// ╚══════════════════════════════════════════════════════════════════════════════╝


// Create Level Function {
// -----------------------------------------------------------------------------

f_create_level(_type, _start_condition, _active_condition, _global_level_array, _color, _line_width, _line_ext, _line_style, _label_size, _title, _iter, _is_enabled) =>
    // _type [ string ] : Determines level type to manage. Available options : "open", "high", "low", "eq"
    // _start_condition [ bool ] : Determines when to obtain initial value
    // _active_condition [ bool ] : Determines when to continue updated value if applicable
    // _global_level_array [ float[] ] : global array where other of same type of levels are stored to find duplicates
    // _color [ color ] : color of line/text
    // _line_ext [ int ] : Distance to extend line to the right
    // _line_style [ const string ] : line style type
    // _label_size [ const string ] : label size used to set text size
    // _title [ string ] : Prefix for level's text
    // _iter [ int ] : How many previous iterations to retrieve level from
    // _is_enabled : Override for disabling level
    var float _price = na
    var int _start_time = na
    var float _hh = na
    var float _ll = na
    var line _price_line = line.new(x1 = na, y1 = na, x2 = na, y2 = na, xloc = xloc.bar_time, color = _color, width = _line_width, style = _line_style)
    var label _price_label = label.new(x = na, y = na, xloc = xloc.bar_time, style = label.style_label_left, color = #00000000, size = _label_size, textcolor = _color)
    
    _end_time = int(time + _line_ext * ta.change(time))
    
    if _type == "open"
        if _start_condition
            _price := open
            _start_time := time
    else if _type == "high"
        if _start_condition
            _price := high
            _start_time := time
        else if _active_condition
            _price := math.max(_price, high)
    else if _type == "low"
        if _start_condition
            _price := low
            _start_time := time
        else if _active_condition
            _price := math.min(_price, low)
    else if _type == "eq"
        if _start_condition
            _hh := high
            _ll := low
            _price := math.avg(_hh, _ll)
            _start_time := time
        else if _active_condition
            _hh := math.max(_hh, high)
            _ll := math.min(_ll, low)
            _price := math.avg(_hh, _ll)
            
    float _price_val = _iter == 0 ? _price : ta.valuewhen(_start_condition, _price[1], _iter - 1)
    int _start_time_val = _iter == 0 ? _start_time : ta.valuewhen(_start_condition, _start_time[1], _iter - 1)
    
    _found_existing = array.indexof(_global_level_array, _price_val) > -1
    
    if _is_enabled
        if _found_existing
            line.set_xy1(_price_line, x = na, y = na)
            line.set_xy2(_price_line, x = na, y = na)
            label.set_xy(_price_label, x = na, y = na)
        else
            array.push(_global_level_array, _price_val)
            line.set_xy1(_price_line, x = _start_time_val, y = _price_val)
            line.set_xy2(_price_line, x = _end_time, y = _price_val)
            label.set_text(_price_label, text = _title + " : " + str.tostring(_price_val))
            label.set_xy(_price_label, x = _end_time, y = _price_val)
            
// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------
// }



// Necessary Variables {
// -----------------------------------------------------------------------------

// Global arrays used to detect duplicate levels.
// Duplication is detected implicitly by execution order and whether the level has already been placed in the global array.
float[] global_open_array = array.new_float()
float[] global_high_array = array.new_float()
float[] global_low_array = array.new_float()
float[] global_eq_array = array.new_float()

new_H4 = ta.change(time("240")) != 0
new_day = ta.change(time("D")) != 0
new_week = ta.change(time("W")) != 0
new_month = ta.change(time("M")) != 0
new_quarter = ta.change(time("3M")) != 0
new_year = ta.change(time("12M")) != 0
is_monday = dayofweek == dayofweek.monday

// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------
// }



// Global settings {
// -----------------------------------------------------------------------------

inp_open_line_style =   input.string("Dotted",  options = ["Solid", "Dotted", "Dashed"], title = "Open Line Style", group = "KEY LEVEL SETTINGS")
inp_high_line_style =   input.string("Solid",   options = ["Solid", "Dotted", "Dashed"], title = "High Line Style", group = "KEY LEVEL SETTINGS")
inp_low_line_style =    input.string("Solid",   options = ["Solid", "Dotted", "Dashed"], title = "Low Line Style",  group = "KEY LEVEL SETTINGS")
inp_eq_line_style =     input.string("Dashed",  options = ["Solid", "Dotted", "Dashed"], title = "EQ Line Style",   group = "KEY LEVEL SETTINGS")

inp_text_size =         input.string("Normal", options = ["Small", "Normal", "Large"], title = "Text Size", group = "KEY LEVEL SETTINGS")
inp_ext =               input.int(5, title = "Line Extension", group = "KEY LEVEL SETTINGS")

text_size = inp_text_size == "Small" ? size.small : inp_text_size == "Normal" ? size.normal : size.large
open_line_style = inp_open_line_style == "Solid" ? line.style_solid : inp_open_line_style == "Dotted" ? line.style_dotted : line.style_dashed
high_line_style = inp_high_line_style == "Solid" ? line.style_solid : inp_high_line_style == "Dotted" ? line.style_dotted : line.style_dashed
low_line_style = inp_low_line_style == "Solid" ? line.style_solid : inp_low_line_style == "Dotted" ? line.style_dotted : line.style_dashed
eq_line_style = inp_eq_line_style == "Solid" ? line.style_solid : inp_eq_line_style == "Dotted" ? line.style_dotted : line.style_dashed

// -----------------------------------------------------------------------------
// -----------------------------------------------------------------------------
// }



// Yearly & Prev Yearly
// -----------------------------------------------------------------------------
inp_show_yearly_open =  input.bool(false, title = "OPEN", group = "Yearly Levels", inline = "1")
inp_show_yearly_high =  input.bool(true, title = "HIGH", group = "Yearly Levels", inline = "1")
inp_show_yearly_low =   input.bool(true, title = "LOW", group = "Yearly Levels", inline = "1")
inp_show_yearly_eq =    input.bool(false, title = "EQ",  group = "Yearly Levels", inline = "1")
inp_yearly_col =        input.color(defval=color.new(color=#000000, transp=0), title = "color", group = "Yearly Levels", inline = "2")
inp_yearly_line_width = input.int(1, title = "Line width", minval = 1, group = "Yearly Levels", inline = "2")

yearly_ok = timeframe.isintraday or timeframe.isdaily or timeframe.isweekly or (timeframe.ismonthly and timeframe.multiplier < 12)

f_create_level("open", new_year, not new_year, global_open_array, inp_yearly_col, inp_yearly_line_width, inp_ext, open_line_style, text_size, "YO", 0, inp_show_yearly_open and yearly_ok)
f_create_level("high", new_year, not new_year, global_high_array, inp_yearly_col, inp_yearly_line_width, inp_ext, high_line_style, text_size, "YH", 0, inp_show_yearly_high and yearly_ok)
f_create_level("low", new_year, not new_year, global_low_array, inp_yearly_col, inp_yearly_line_width, inp_ext, low_line_style, text_size, "YL", 0, inp_show_yearly_low and yearly_ok)
f_create_level("eq", new_year, not new_year, global_eq_array, inp_yearly_col, inp_yearly_line_width, inp_ext, eq_line_style, text_size, "YEQ", 0, inp_show_yearly_eq and yearly_ok)


inp_show_prev_yearly_open =  input.bool(false, title = "OPEN", group = "Prev Yearly Levels", inline = "1")
inp_show_prev_yearly_high =  input.bool(true, title = "HIGH", group = "Prev Yearly Levels", inline = "1")
inp_show_prev_yearly_low =   input.bool(true, title = "LOW", group = "Prev Yearly Levels", inline = "1")
inp_show_prev_yearly_eq =    input.bool(false, title = "EQ",  group = "Prev Yearly Levels", inline = "1")
inp_prev_yearly_col =        input.color(defval=color.new(color=#000000, transp=0), group = "Prev Yearly Levels", inline = "2")
inp_prev_yearly_line_width = input.int(1, title = "Line width", minval = 1, group = "Prev Yearly Levels", inline = "2")

f_create_level("open", new_year, not new_year, global_open_array, inp_prev_yearly_col, inp_prev_yearly_line_width, inp_ext, open_line_style, text_size, "PYO", 1, inp_show_prev_yearly_open and yearly_ok)
f_create_level("high", new_year, not new_year, global_high_array, inp_prev_yearly_col, inp_prev_yearly_line_width, inp_ext, high_line_style, text_size, "PYH", 1, inp_show_prev_yearly_high and yearly_ok)
f_create_level("low", new_year, not new_year, global_low_array, inp_prev_yearly_col, inp_prev_yearly_line_width, inp_ext, low_line_style, text_size, "PYL", 1, inp_show_prev_yearly_low and yearly_ok)
f_create_level("eq", new_year, not new_year, global_eq_array, inp_prev_yearly_col, inp_prev_yearly_line_width, inp_ext, eq_line_style, text_size, "PYEQ", 1, inp_show_prev_yearly_eq and yearly_ok)
// -----------------------------------------------------------------------------



// Quarterly and Prev Quarterly
// -----------------------------------------------------------------------------
inp_show_quarterly_open =  input.bool(false, title = "OPEN", group = "Quarterly Levels", inline = "1")
inp_show_quarterly_high =  input.bool(false, title = "HIGH", group = "Quarterly Levels", inline = "1")
inp_show_quarterly_low =   input.bool(false, title = "LOW", group = "Quarterly Levels", inline = "1")
inp_show_quarterly_eq =    input.bool(false, title = "EQ",  group = "Quarterly Levels", inline = "1")
inp_quarterly_col =        input.color(defval=color.new(color=#000000, transp=0), title = "color", group = "Quarterly Levels", inline = "2")
inp_quarterly_line_width = input.int(1, title = "Line width", minval = 1, group = "Quarterly Levels", inline = "2")

quarterly_ok = timeframe.isintraday or timeframe.isdaily or timeframe.isweekly

f_create_level("open", new_quarter, not new_quarter, global_open_array, inp_quarterly_col, inp_quarterly_line_width, inp_ext, open_line_style, text_size, "QO", 0, inp_show_quarterly_open and quarterly_ok)
f_create_level("high", new_quarter, not new_quarter, global_high_array, inp_quarterly_col, inp_quarterly_line_width, inp_ext, high_line_style, text_size, "QH", 0, inp_show_quarterly_high and quarterly_ok)
f_create_level("low", new_quarter, not new_quarter, global_low_array, inp_quarterly_col, inp_quarterly_line_width, inp_ext, low_line_style, text_size, "QL", 0, inp_show_quarterly_low and quarterly_ok)
f_create_level("eq", new_quarter, not new_quarter, global_eq_array, inp_quarterly_col, inp_quarterly_line_width, inp_ext, eq_line_style, text_size, "QEQ", 0, inp_show_quarterly_eq and quarterly_ok)


inp_show_prev_quarterly_open =  input.bool(false, title = "OPEN", group = "Prev Quarterly Levels", inline = "1")
inp_show_prev_quarterly_high =  input.bool(false, title = "HIGH", group = "Prev Quarterly Levels", inline = "1")
inp_show_prev_quarterly_low =   input.bool(false, title = "LOW", group = "Prev Quarterly Levels", inline = "1")
inp_show_prev_quarterly_eq =    input.bool(false, title = "EQ",  group = "Prev Quarterly Levels", inline = "1")
inp_prev_quarterly_col =        input.color(defval=color.new(color=#000000, transp=0), title = "color", group = "Prev Quarterly Levels", inline = "2")
inp_prev_quarterly_line_width = input.int(1, title = "Line width", minval = 1, group = "Prev Quarterly Levels", inline = "2")

f_create_level("open", new_quarter, not new_quarter, global_open_array, inp_prev_quarterly_col, inp_prev_quarterly_line_width, inp_ext, open_line_style, text_size, "PQO", 1, inp_show_prev_quarterly_open and quarterly_ok)
f_create_level("high", new_quarter, not new_quarter, global_high_array, inp_prev_quarterly_col, inp_prev_quarterly_line_width, inp_ext, high_line_style, text_size, "PQH", 1, inp_show_prev_quarterly_high and quarterly_ok)
f_create_level("low", new_quarter, not new_quarter, global_low_array, inp_prev_quarterly_col, inp_prev_quarterly_line_width, inp_ext, low_line_style, text_size, "PQL", 1, inp_show_prev_quarterly_low and quarterly_ok)
f_create_level("eq", new_quarter, not new_quarter, global_eq_array, inp_prev_quarterly_col, inp_prev_quarterly_line_width, inp_ext, eq_line_style, text_size, "PQEQ", 1, inp_show_prev_quarterly_eq and quarterly_ok)
// -----------------------------------------------------------------------------




// Monthly and Prev Monthly
// -----------------------------------------------------------------------------
inp_show_monthly_open =  input.bool(false, title = "OPEN", group = "Monthly Levels", inline = "1")
inp_show_monthly_high =  input.bool(true, title = "HIGH", group = "Monthly Levels", inline = "1")
inp_show_monthly_low =   input.bool(true, title = "LOW", group = "Monthly Levels", inline = "1")
inp_show_monthly_eq =    input.bool(false, title = "EQ",  group = "Monthly Levels", inline = "1")
inp_monthly_col =        input.color(defval=color.new(color=#000000, transp=0), title = "color", group = "Monthly Levels", inline = "2")
inp_monthly_line_width = input.int(1, title = "Line width", minval = 1, group = "Monthly Levels", inline = "2")

monthly_ok = timeframe.isintraday or timeframe.isdaily

f_create_level("open", new_month, not new_month, global_open_array, inp_monthly_col, inp_monthly_line_width, inp_ext, open_line_style, text_size, "MO", 0, inp_show_monthly_open and monthly_ok)
f_create_level("high", new_month, not new_month, global_high_array, inp_monthly_col, inp_monthly_line_width, inp_ext, high_line_style, text_size, "MH", 0, inp_show_monthly_high and monthly_ok)
f_create_level("low", new_month, not new_month, global_low_array, inp_monthly_col, inp_monthly_line_width, inp_ext, low_line_style, text_size, "ML", 0, inp_show_monthly_low and monthly_ok)
f_create_level("eq", new_month, not new_month, global_eq_array, inp_monthly_col, inp_monthly_line_width, inp_ext, eq_line_style, text_size, "MEQ", 0, inp_show_monthly_eq and monthly_ok)


inp_show_prev_monthly_open =  input.bool(false, title = "OPEN", group = "Prev Monthly Levels", inline = "1")
inp_show_prev_monthly_high =  input.bool(true, title = "HIGH", group = "Prev Monthly Levels", inline = "1")
inp_show_prev_monthly_low =   input.bool(true, title = "LOW", group = "Prev Monthly Levels", inline = "1")
inp_show_prev_monthly_eq =    input.bool(false, title = "EQ",  group = "Prev Monthly Levels", inline = "1")
inp_prev_monthly_col =        input.color(defval=color.new(color=#000000, transp=0), title = "color", group = "Prev Monthly Levels", inline = "2")
inp_prev_monthly_line_width = input.int(1, title = "Line width", minval = 1, group = "Prev Monthly Levels", inline = "2")

f_create_level("open", new_month, not new_month, global_open_array, inp_prev_monthly_col, inp_prev_monthly_line_width, inp_ext, open_line_style, text_size, "PMO", 1, inp_show_prev_monthly_open and monthly_ok)
f_create_level("high", new_month, not new_month, global_high_array, inp_prev_monthly_col, inp_prev_monthly_line_width, inp_ext, high_line_style, text_size, "PMH", 1, inp_show_prev_monthly_high and monthly_ok)
f_create_level("low", new_month, not new_month, global_low_array, inp_prev_monthly_col, inp_prev_monthly_line_width, inp_ext, low_line_style, text_size, "PML", 1, inp_show_prev_monthly_low and monthly_ok)
f_create_level("eq", new_month, not new_month, global_eq_array, inp_prev_monthly_col, inp_prev_monthly_line_width, inp_ext, eq_line_style, text_size, "PMEQ", 1, inp_show_prev_monthly_eq and monthly_ok)
// -----------------------------------------------------------------------------



// Weekly and Prev Weekly
// -----------------------------------------------------------------------------
inp_show_weekly_open =  input.bool(true, title = "OPEN", group = "Weekly Levels", inline = "1")
inp_show_weekly_high =  input.bool(true, title = "HIGH", group = "Weekly Levels", inline = "1")
inp_show_weekly_low =   input.bool(true, title = "LOW", group = "Weekly Levels", inline = "1")
inp_show_weekly_eq =    input.bool(false, title = "EQ",  group = "Weekly Levels", inline = "1")
inp_weekly_col =        input.color(defval=color.new(color=#111acf, transp=0), title = "color", group = "Weekly Levels", inline = "2")
inp_weekly_line_width = input.int(1, title = "Line width", minval = 1, group = "Weekly Levels", inline = "2")

weekly_ok = timeframe.isintraday or timeframe.isdaily

f_create_level("open", new_week, not new_week, global_open_array, inp_weekly_col, inp_weekly_line_width, inp_ext, open_line_style, text_size, "WO", 0, inp_show_weekly_open and weekly_ok)
f_create_level("high", new_week, not new_week, global_high_array, inp_weekly_col, inp_weekly_line_width, inp_ext, high_line_style, text_size, "WH", 0, inp_show_weekly_high and weekly_ok)
f_create_level("low", new_week, not new_week, global_low_array, inp_weekly_col, inp_weekly_line_width, inp_ext, low_line_style, text_size, "WL", 0, inp_show_weekly_low and weekly_ok)
f_create_level("eq", new_week, not new_week, global_eq_array, inp_weekly_col, inp_weekly_line_width, inp_ext, eq_line_style, text_size, "WEQ", 0, inp_show_weekly_eq and weekly_ok)


inp_show_prev_weekly_open =  input.bool(false, title = "OPEN", group = "Prev Weekly Levels", inline = "1")
inp_show_prev_weekly_high =  input.bool(true, title = "HIGH", group = "Prev Weekly Levels", inline = "1")
inp_show_prev_weekly_low =   input.bool(true, title = "LOW", group = "Prev Weekly Levels", inline = "1")
inp_show_prev_weekly_eq =    input.bool(false, title = "EQ",  group = "Prev Weekly Levels", inline = "1")
inp_prev_weekly_col =        input.color(defval=color.new(color=#111acf, transp=0), title = "color", group = "Prev Weekly Levels", inline = "2")
inp_prev_weekly_line_width = input.int(1, title = "Line width", minval = 1, group = "Prev Weekly Levels", inline = "2")



f_create_level("open", new_week, not new_week, global_open_array, inp_prev_weekly_col, inp_prev_weekly_line_width, inp_ext, open_line_style, text_size, "PWO", 1, inp_show_prev_weekly_open and weekly_ok)
f_create_level("high", new_week, not new_week, global_high_array, inp_prev_weekly_col, inp_prev_weekly_line_width, inp_ext, high_line_style, text_size, "PWH", 1, inp_show_prev_weekly_high and weekly_ok)
f_create_level("low", new_week, not new_week, global_low_array, inp_prev_weekly_col, inp_prev_weekly_line_width, inp_ext, low_line_style, text_size, "PWL", 1, inp_show_prev_weekly_low and weekly_ok)
f_create_level("eq", new_week, not new_week, global_eq_array, inp_prev_weekly_col, inp_prev_weekly_line_width, inp_ext, eq_line_style, text_size, "PWEQ", 1, inp_show_prev_weekly_eq and weekly_ok)
// -----------------------------------------------------------------------------




// Daily and Prev Daily
// -----------------------------------------------------------------------------
inp_show_daily_open =  input.bool(false, title = "OPEN", group = "Daily Levels", inline = "1")
inp_show_daily_high =  input.bool(false, title = "HIGH", group = "Daily Levels", inline = "1")
inp_show_daily_low =   input.bool(false, title = "LOW", group = "Daily Levels", inline = "1")
inp_show_daily_eq =    input.bool(false, title = "EQ",  group = "Daily Levels", inline = "1")
inp_daily_col =        input.color(defval=color.new(color=#000000, transp=0), title = "color", group = "Daily Levels", inline = "2")
inp_daily_line_width = input.int(1, title = "Line width", minval = 1, group = "Daily Levels", inline = "2")

daily_ok = timeframe.isintraday

f_create_level("open", new_day, not new_day, global_open_array, inp_daily_col, inp_daily_line_width, inp_ext, open_line_style, text_size, "DO", 0, inp_show_daily_open and daily_ok)
f_create_level("high", new_day, not new_day, global_high_array, inp_daily_col, inp_daily_line_width, inp_ext, high_line_style, text_size, "DH", 0, inp_show_daily_high and daily_ok)
f_create_level("low", new_day, not new_day, global_low_array, inp_daily_col, inp_daily_line_width, inp_ext, low_line_style, text_size, "DL", 0, inp_show_daily_low and daily_ok)
f_create_level("eq", new_day, not new_day, global_eq_array, inp_daily_col, inp_daily_line_width, inp_ext, eq_line_style, text_size, "DEQ", 0, inp_show_daily_eq and daily_ok)


inp_show_prev_daily_open =  input.bool(false, title = "OPEN", group = "Prev Daily Levels", inline = "1")
inp_show_prev_daily_high =  input.bool(false, title = "HIGH", group = "Prev Daily Levels", inline = "1")
inp_show_prev_daily_low =   input.bool(false, title = "LOW", group = "Prev Daily Levels", inline = "1")
inp_show_prev_daily_eq =    input.bool(false, title = "EQ",  group = "Prev Daily Levels", inline = "1")
inp_prev_daily_col =        input.color(defval=color.new(color=#000000, transp=0), title = "color", group = "Prev Daily Levels", inline = "2")
inp_prev_daily_line_width = input.int(1, title = "Line width", minval = 1, group = "Prev Daily Levels", inline = "2")

f_create_level("open", new_day, not new_day, global_open_array, inp_prev_daily_col, inp_prev_daily_line_width, inp_ext, open_line_style, text_size, "PDO", 1, inp_show_prev_daily_open and daily_ok)
f_create_level("high", new_day, not new_day, global_high_array, inp_prev_daily_col, inp_prev_daily_line_width, inp_ext, high_line_style, text_size, "PDH", 1, inp_show_prev_daily_high and daily_ok)
f_create_level("low", new_day, not new_day, global_low_array, inp_prev_daily_col, inp_prev_daily_line_width, inp_ext, low_line_style, text_size, "PDL", 1, inp_show_prev_daily_low and daily_ok)
f_create_level("eq", new_day, not new_day, global_eq_array, inp_prev_daily_col, inp_prev_daily_line_width, inp_ext, eq_line_style, text_size, "PDEQ", 1, inp_show_prev_daily_eq and daily_ok)
// -----------------------------------------------------------------------------



// Monday and Prev Monday
// -----------------------------------------------------------------------------
// Note : Monday range is a special case and is why the _active_condition is implemented in the function. We only want start on Monday, and ONLY update levels during monday.
inp_show_monday_open =  input.bool(false, title = "OPEN", group = "Monday Levels", inline = "1")
inp_show_monday_high =  input.bool(false, title = "HIGH", group = "Monday Levels", inline = "1")
inp_show_monday_low =   input.bool(false, title = "LOW", group = "Monday Levels", inline = "1")
inp_show_monday_eq =    input.bool(false, title = "EQ",  group = "Monday Levels", inline = "1")
inp_monday_col =        input.color(defval=color.new(color=#000000, transp=0), title = "color", group = "Monday Levels", inline = "2")
inp_monday_line_width = input.int(1, title = "Line width", minval = 1, group = "Monday Levels", inline = "2")

monday_ok = timeframe.isintraday

f_create_level("open", new_week, is_monday, global_open_array, inp_monday_col, inp_monday_line_width, inp_ext, open_line_style, text_size, "MO", 0, inp_show_monday_open and monday_ok)
f_create_level("high", new_week, is_monday, global_high_array, inp_monday_col, inp_monday_line_width, inp_ext, high_line_style, text_size, "MH", 0, inp_show_monday_high and monday_ok)
f_create_level("low", new_week, is_monday, global_low_array, inp_monday_col, inp_monday_line_width, inp_ext, low_line_style, text_size, "ML", 0, inp_show_monday_low and monday_ok)
f_create_level("eq", new_week, is_monday, global_eq_array, inp_monday_col, inp_monday_line_width, inp_ext, eq_line_style, text_size, "MEQ", 0, inp_show_monday_eq and monday_ok)


inp_show_prev_monday_open =  input.bool(false, title = "OPEN", group = "Prev Monday Levels", inline = "1")
inp_show_prev_monday_high =  input.bool(false, title = "HIGH", group = "Prev Monday Levels", inline = "1")
inp_show_prev_monday_low =   input.bool(false, title = "LOW", group = "Prev Monday Levels", inline = "1")
inp_show_prev_monday_eq =    input.bool(false, title = "EQ",  group = "Prev Monday Levels", inline = "1")
inp_prev_monday_col =        input.color(defval=color.new(color=#000000, transp=0), title = "color", group = "Prev Monday Levels", inline = "2")
inp_prev_monday_line_width = input.int(1, title = "Line width", minval = 1, group = "Prev Monday Levels", inline = "2")

f_create_level("open", new_week, is_monday, global_open_array, inp_prev_monday_col, inp_prev_monday_line_width, inp_ext, open_line_style, text_size, "PMO", 1, inp_show_prev_monday_open and monday_ok)
f_create_level("high", new_week, is_monday, global_high_array, inp_prev_monday_col, inp_prev_monday_line_width, inp_ext, high_line_style, text_size, "PMH", 1, inp_show_prev_monday_high and monday_ok)
f_create_level("low", new_week, is_monday, global_low_array, inp_prev_monday_col, inp_prev_monday_line_width, inp_ext, low_line_style, text_size, "PML", 1, inp_show_prev_monday_low and monday_ok)
f_create_level("eq", new_week, is_monday, global_eq_array, inp_prev_monday_col, inp_prev_monday_line_width, inp_ext, eq_line_style, text_size, "PMEQ", 1, inp_show_prev_monday_eq and monday_ok)
// -----------------------------------------------------------------------------



// H4 and Prev H4
// -----------------------------------------------------------------------------
inp_show_H4_open =  input.bool(false, title = "OPEN", group = "H4 Levels", inline = "1")
inp_show_H4_high =  input.bool(false, title = "HIGH", group = "H4 Levels", inline = "1")
inp_show_H4_low =   input.bool(false, title = "LOW", group = "H4 Levels", inline = "1")
inp_show_H4_eq =    input.bool(false, title = "EQ",  group = "H4 Levels", inline = "1")
inp_H4_col =        input.color(defval=color.new(color=#000000, transp=0), title = "color", group = "H4 Levels", inline = "2")
inp_H4_line_width = input.int(1, title = "Line width", minval = 1, group = "H4 Levels", inline = "2")

H4_ok = timeframe.isintraday and timeframe.multiplier < 240

f_create_level("open", new_H4, not new_H4, global_open_array, inp_H4_col, inp_H4_line_width, inp_ext, open_line_style, text_size, "H4 OPEN", 0, inp_show_H4_open and H4_ok)
f_create_level("high", new_H4, not new_H4, global_high_array, inp_H4_col, inp_H4_line_width, inp_ext, high_line_style, text_size, "H4 HIGH", 0, inp_show_H4_high and H4_ok)
f_create_level("low", new_H4, not new_H4, global_low_array, inp_H4_col, inp_H4_line_width, inp_ext, low_line_style, text_size, "H4 LOW", 0, inp_show_H4_low and H4_ok)
f_create_level("eq", new_H4, not new_H4, global_eq_array, inp_H4_col, inp_H4_line_width, inp_ext, eq_line_style, text_size, "H4 EQ", 0, inp_show_H4_eq and H4_ok)


inp_show_prev_H4_open =  input.bool(false, title = "OPEN", group = "Prev H4 Levels", inline = "1")
inp_show_prev_H4_high =  input.bool(false, title = "HIGH", group = "Prev H4 Levels", inline = "1")
inp_show_prev_H4_low =   input.bool(false, title = "LOW", group = "Prev H4 Levels", inline = "1")
inp_show_prev_H4_eq =    input.bool(false, title = "EQ",  group = "Prev H4 Levels", inline = "1")
inp_prev_H4_col =        input.color(defval=color.new(color=#000000, transp=0), title = "color", group = "Prev H4 Levels", inline = "2")
inp_prev_H4_line_width = input.int(1, title = "Line width", minval = 1, group = "Prev H4 Levels", inline = "2")

f_create_level("open", new_H4, not new_H4, global_open_array, inp_prev_H4_col, inp_prev_H4_line_width, inp_ext, open_line_style, text_size, "Prev H4 OPEN", 1, inp_show_prev_H4_open and H4_ok)
f_create_level("high", new_H4, not new_H4, global_high_array, inp_prev_H4_col, inp_prev_H4_line_width, inp_ext, high_line_style, text_size, "Prev H4 HIGH", 1, inp_show_prev_H4_high and H4_ok)
f_create_level("low", new_H4, not new_H4, global_low_array, inp_prev_H4_col, inp_prev_H4_line_width, inp_ext, low_line_style, text_size, "Prev H4 LOW", 1, inp_show_prev_H4_low and H4_ok)
f_create_level("eq", new_H4, not new_H4, global_eq_array, inp_prev_H4_col, inp_prev_H4_line_width, inp_ext, eq_line_style, text_size, "Prev H4 EQ", 1, inp_show_prev_H4_eq and H4_ok)
// -----------------------------------------------------------------------------

// ╔══════════════════════════════════════════════════════════════════════════════╗
// ║                                                                              ║
// ║     main finish (key levels)                                                 ║
// ║                                                                              ║
// ╚══════════════════════════════════════════════════════════════════════════════╝


// ╔══════════════════════════════════════════════════════════════════════════════╗
// ║                                                                              ║
// ║                That's all Folks !                                            ║
// ║                                                                              ║
// ╚══════════════════════════════════════════════════════════════════════════════╝
